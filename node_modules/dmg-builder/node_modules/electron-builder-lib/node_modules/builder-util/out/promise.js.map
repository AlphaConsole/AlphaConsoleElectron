{"version":3,"file":"promise.js","sourceRoot":"","sources":["../src/promise.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAOA,AAA6F,AAC7F,AAAM;;oEAAC,AAAK,WAA4B,AAAmB,SAAE,AAA8C;AACzG,YAAI,AAAM,SAAa,AAAI;AAC3B,YAAI,AAAC;AACH,AAAM,qBAAG,MAAM,AAAO,AACxB;AAAC,UACD,AAAK,AAAC,OAAC,AAAa,AAAC,eAAC,AAAC;AACrB,gBAAI,AAAC;AACH,sBAAM,AAAI,KAAC,AAAI,AAAC,AAClB;AAAC,cACD,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,sBAAM,IAAI,AAAW,YAAC,CAAC,AAAa,eAAE,AAAS,AAAC,AAAC,AACnD;AAAC;AAED,kBAAM,AAAa,AACrB;AAAC;AAED,YAAI,AAAC;AACH,kBAAM,AAAI,KAAC,AAAK,AAAC,AACnB;AAAC,UACD,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,kBAAM,AAAS,AACjB;AAAC;AACD,AAAM,eAAC,AAAM,AACf;AAAC,AAED,AAAM;;;;;;;;;;;;;AAjCN,AAAO,AAAK,AAAM,AAAO,AAEzB,AAAM;;;;;;2BAA4B,AAAY;AAC5C,AAAO,YAAC,AAAK,MAAC,AAAK,kCAAC,AAAG,IAAC,CAAC,AAAK,MAAC,AAAK,SAAI,AAAK,AAAC,OAAC,AAAQ,AAAE,AAAC,AAAC;AAC3D,AAAO,YAAC,AAAI,KAAC,AAAC,AAAC,AACjB;AAAC,OA4BwB,oBAAQ,AAAK;AACpC,gBAAY,AAAoB,QAAE,UAAkB,AAAkB;AACpE,YAAI,AAAC,IAAG,AAAO;AACf,YAAI,AAAC,IAAG,AAAC;AACT,AAAG,AAAC,aAAC,MAAM,AAAK,SAAI,AAAM,AAAC,QAAC,AAAC;AAC3B,kBAAM,AAAM,AAAG,mBAAU,AAAC,AAAE,GAAG;AAC/B,AAAC,iBAAI,AAAM,SAAG,AAAM,SAAG,AAAG,IAAC,AAAM,OAAC,AAAE,AAAC,MAAG,AAAI,OAAG,AAAM,MAAC,AAAK,AAC7D;AAAC;AACD,AAAK,cAAC,AAAC,AAAC,AACV;AAAC,AACF,AAED,AAAM;;;8BAAkC,AAAmB;AACzD,AAAM,WAAC,AAAgB,iBAAC,AAAO,SAAE,AAAI,AAAC,AACxC;AAAC,AAED,AAAM;0BAA8B,AAAmB,SAAE,AAAgB;AACvE,AAAM,mBACH,AAAK,MAAC,AAAC,AAAC,AAAE;AACT,AAAE,AAAC,YAAC,AAAC,EAAC,AAAI,SAAK,AAAQ,YAAI,AAAC,EAAC,AAAI,SAAK,AAAS,AAAC,WAAC,AAAC;AAChD,AAAM,mBAAC,AAAa,AACtB;AAAC;AACD,cAAM,AAAC,AACT;AAAC,AAAC,AACN,KAPS,AAAO;AAOf","sourcesContent":["import chalk from \"chalk\"\n\nexport function printErrorAndExit(error: Error) {\n  console.error(chalk.red((error.stack || error).toString()))\n  process.exit(1)\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nexport async function executeFinally<T>(promise: Promise<T>, task: (errorOccurred: boolean) => Promise<any>): Promise<T> {\n  let result: T | null = null\n  try {\n    result = await promise\n  }\n  catch (originalError) {\n    try {\n      await task(true)\n    }\n    catch (taskError) {\n      throw new NestedError([originalError, taskError])\n    }\n\n    throw originalError\n  }\n\n  try {\n    await task(false)\n  }\n  catch (taskError) {\n    throw taskError\n  }\n  return result\n}\n\nexport class NestedError extends Error {\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\n    let m = message\n    let i = 1\n    for (const error of errors) {\n      const prefix = `Error #${i++} `\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error!.stack\n    }\n    super(m)\n  }\n}\n\nexport function orNullIfFileNotExist<T>(promise: Promise<T>): Promise<T | null> {\n  return orIfFileNotExist(promise, null)\n}\n\nexport function orIfFileNotExist<T>(promise: Promise<T>, fallbackValue: T): Promise<T> {\n  return promise\n    .catch(e => {\n      if (e.code === \"ENOENT\" || e.code === \"ENOTDIR\") {\n        return fallbackValue\n      }\n      throw e\n    })\n}"]}
