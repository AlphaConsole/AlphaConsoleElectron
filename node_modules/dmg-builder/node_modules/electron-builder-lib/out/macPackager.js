"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _electronOsxSign;

function _load_electronOsxSign() {
    return _electronOsxSign = require("electron-osx-sign");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = require("lazy-val");
}

var _path = _interopRequireWildcard(require("path"));

var _semver;

function _load_semver() {
    return _semver = _interopRequireWildcard(require("semver"));
}

var _out;

function _load_out() {
    return _out = require("builder-util-runtime/out");
}

var _appInfo;

function _load_appInfo() {
    return _appInfo = require("./appInfo");
}

var _codeSign;

function _load_codeSign() {
    return _codeSign = require("./codeSign");
}

var _core;

function _load_core() {
    return _core = require("./core");
}

var _mac;

function _load_mac() {
    return _mac = require("./packager/mac");
}

var _platformPackager;

function _load_platformPackager() {
    return _platformPackager = require("./platformPackager");
}

var _ArchiveTarget;

function _load_ArchiveTarget() {
    return _ArchiveTarget = require("./targets/ArchiveTarget");
}

var _pkg;

function _load_pkg() {
    return _pkg = require("./targets/pkg");
}

var _targetFactory;

function _load_targetFactory() {
    return _targetFactory = require("./targets/targetFactory");
}

var _fs;

function _load_fs() {
    return _fs = require("builder-util/out/fs");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MacPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        super(info, (_core || _load_core()).Platform.MAC);
        this.codeSigningInfo = new (_lazyVal || _load_lazyVal()).Lazy(() => {
            const cscLink = this.getCscLink();
            if (cscLink == null || process.platform !== "darwin") {
                return Promise.resolve({ keychainName: process.env.CSC_KEYCHAIN || null });
            }
            return (0, (_codeSign || _load_codeSign()).createKeychain)({
                tmpDir: this.info.tempDirManager,
                cscLink,
                cscKeyPassword: this.getCscPassword(),
                cscILink: (0, (_platformPackager || _load_platformPackager()).chooseNotNull)(this.platformSpecificBuildOptions.cscInstallerLink, process.env.CSC_INSTALLER_LINK),
                cscIKeyPassword: (0, (_platformPackager || _load_platformPackager()).chooseNotNull)(this.platformSpecificBuildOptions.cscInstallerKeyPassword, process.env.CSC_INSTALLER_KEY_PASSWORD),
                currentDir: this.projectDir
            });
        });
        this._iconPath = new (_lazyVal || _load_lazyVal()).Lazy(() => this.getOrConvertIcon("icns"));
    }
    get defaultTarget() {
        const electronUpdaterCompatibility = this.platformSpecificBuildOptions.electronUpdaterCompatibility;
        return electronUpdaterCompatibility == null || (_semver || _load_semver()).satisfies("2.16.0", electronUpdaterCompatibility) ? ["zip", "dmg"] : ["dmg"];
    }
    prepareAppInfo(appInfo) {
        return new (_appInfo || _load_appInfo()).AppInfo(this.info, this.platformSpecificBuildOptions.bundleVersion);
    }
    getIconPath() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            return _this._iconPath.value;
        })();
    }
    createTargets(targets, mapper) {
        for (const name of targets) {
            switch (name) {
                case (_core || _load_core()).DIR_TARGET:
                    break;
                case "dmg":
                    const { DmgTarget } = require("dmg-builder");
                    mapper(name, outDir => new DmgTarget(this, outDir));
                    break;
                case "zip":
                    // https://github.com/electron-userland/electron-builder/issues/2313
                    mapper(name, outDir => new (_ArchiveTarget || _load_ArchiveTarget()).ArchiveTarget(name, outDir, this, true));
                    break;
                case "pkg":
                    mapper(name, outDir => new (_pkg || _load_pkg()).PkgTarget(this, outDir));
                    break;
                default:
                    mapper(name, outDir => name === "mas" || name === "mas-dev" ? new (_targetFactory || _load_targetFactory()).NoOpTarget(name) : (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this));
                    break;
            }
        }
    }
    pack(outDir, arch, targets, taskManager) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let nonMasPromise = null;
            const hasMas = targets.length !== 0 && targets.some(function (it) {
                return it.name === "mas" || it.name === "mas-dev";
            });
            const prepackaged = _this2.packagerOptions.prepackaged;
            if (!hasMas || targets.length > 1) {
                const appPath = prepackaged == null ? _path.join(_this2.computeAppOutDir(outDir, arch), `${_this2.appInfo.productFilename}.app`) : prepackaged;
                nonMasPromise = (prepackaged ? Promise.resolve() : _this2.doPack(outDir, _path.dirname(appPath), _this2.platform.nodeName, arch, _this2.platformSpecificBuildOptions, targets)).then(function () {
                    return _this2.sign(appPath, null, null);
                }).then(function () {
                    return _this2.packageInDistributableFormat(appPath, (_builderUtil || _load_builderUtil()).Arch.x64, targets, taskManager);
                });
            }
            for (const target of targets) {
                const targetName = target.name;
                if (!(targetName === "mas" || targetName === "mas-dev")) {
                    continue;
                }
                const masBuildOptions = (0, (_builderUtil || _load_builderUtil()).deepAssign)({}, _this2.platformSpecificBuildOptions, _this2.config.mas);
                if (targetName === "mas-dev") {
                    (0, (_builderUtil || _load_builderUtil()).deepAssign)(masBuildOptions, _this2.config[targetName], {
                        type: "development"
                    });
                }
                const targetOutDir = _path.join(outDir, targetName);
                if (prepackaged == null) {
                    yield _this2.doPack(outDir, targetOutDir, "mas", arch, masBuildOptions, [target]);
                    yield _this2.sign(_path.join(targetOutDir, `${_this2.appInfo.productFilename}.app`), targetOutDir, masBuildOptions);
                } else {
                    yield _this2.sign(prepackaged, targetOutDir, masBuildOptions);
                }
            }
            if (nonMasPromise != null) {
                yield nonMasPromise;
            }
        })();
    }
    sign(appPath, outDir, masOptions) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (!(0, (_codeSign || _load_codeSign()).isSignAllowed)()) {
                return;
            }
            const isMas = masOptions != null;
            const macOptions = _this3.platformSpecificBuildOptions;
            const qualifier = (isMas ? masOptions.identity : null) || macOptions.identity;
            if (!isMas && qualifier === null) {
                if (_this3.forceCodeSigning) {
                    throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError("identity explicitly is set to null, but forceCodeSigning is set to true");
                }
                (_builderUtil || _load_builderUtil()).log.info({ reason: "identity explicitly is set to null" }, "skipped macOS code signing");
                return;
            }
            const keychainName = (yield _this3.codeSigningInfo.value).keychainName;
            const explicitType = isMas ? masOptions.type : macOptions.type;
            const type = explicitType || "distribution";
            const isDevelopment = type === "development";
            const certificateType = getCertificateType(isMas, isDevelopment);
            let identity = yield (0, (_codeSign || _load_codeSign()).findIdentity)(certificateType, qualifier, keychainName);
            if (identity == null) {
                if (!isMas && !isDevelopment && explicitType !== "distribution") {
                    identity = yield (0, (_codeSign || _load_codeSign()).findIdentity)("Mac Developer", qualifier, keychainName);
                    if (identity != null) {
                        (_builderUtil || _load_builderUtil()).log.warn("Mac Developer is used to sign app â€” it is only for development and testing, not for production");
                    }
                }
                if (identity == null) {
                    yield (0, (_codeSign || _load_codeSign()).reportError)(isMas, certificateType, qualifier, keychainName, _this3.forceCodeSigning);
                    return;
                }
            }
            const signOptions = {
                "identity-validation": false,
                // https://github.com/electron-userland/electron-builder/issues/1699
                // kext are signed by the chipset manufacturers. You need a special certificate (only available on request) from Apple to be able to sign kext.
                ignore: function (file) {
                    return file.endsWith(".kext") || file.startsWith("/Contents/PlugIns", appPath.length) ||
                    // https://github.com/electron-userland/electron-builder/issues/2010
                    file.includes("/node_modules/puppeteer/.local-chromium");
                },
                identity: identity,
                type,
                platform: isMas ? "mas" : "darwin",
                version: _this3.config.electronVersion,
                app: appPath,
                keychain: keychainName || undefined,
                binaries: (isMas && masOptions != null ? masOptions.binaries : macOptions.binaries) || undefined,
                requirements: isMas || macOptions.requirements == null ? undefined : yield _this3.getResource(macOptions.requirements),
                "gatekeeper-assess": (_codeSign || _load_codeSign()).appleCertificatePrefixes.find(function (it) {
                    return identity.name.startsWith(it);
                }) != null
            };
            yield _this3.adjustSignOptions(signOptions, masOptions);
            (_builderUtil || _load_builderUtil()).log.info({
                file: (_builderUtil || _load_builderUtil()).log.filePath(appPath),
                identityName: identity.name,
                identityHash: identity.hash
            }, "signing");
            yield _this3.doSign(signOptions);
            // https://github.com/electron-userland/electron-builder/issues/1196#issuecomment-312310209
            if (masOptions != null && !isDevelopment) {
                const certType = isDevelopment ? "Mac Developer" : "3rd Party Mac Developer Installer";
                const masInstallerIdentity = yield (0, (_codeSign || _load_codeSign()).findIdentity)(certType, masOptions.identity, keychainName);
                if (masInstallerIdentity == null) {
                    throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError(`Cannot find valid "${certType}" identity to sign MAS installer, please see https://electron.build/code-signing`);
                }
                const artifactName = _this3.expandArtifactNamePattern(masOptions, "pkg");
                const artifactPath = _path.join(outDir, artifactName);
                yield _this3.doFlat(appPath, artifactPath, masInstallerIdentity, keychainName);
                _this3.dispatchArtifactCreated(artifactPath, null, (_builderUtil || _load_builderUtil()).Arch.x64, _this3.computeSafeArtifactName(artifactName, "pkg"));
            }
        })();
    }
    adjustSignOptions(signOptions, masOptions) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const resourceList = yield _this4.resourceList;
            if (resourceList.includes(`entitlements.osx.plist`)) {
                throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError("entitlements.osx.plist is deprecated name, please use entitlements.mac.plist");
            }
            if (resourceList.includes(`entitlements.osx.inherit.plist`)) {
                throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError("entitlements.osx.inherit.plist is deprecated name, please use entitlements.mac.inherit.plist");
            }
            const customSignOptions = masOptions || _this4.platformSpecificBuildOptions;
            const entitlementsSuffix = masOptions == null ? "mac" : "mas";
            if (customSignOptions.entitlements == null) {
                const p = `entitlements.${entitlementsSuffix}.plist`;
                if (resourceList.includes(p)) {
                    signOptions.entitlements = _path.join(_this4.info.buildResourcesDir, p);
                }
            } else {
                signOptions.entitlements = customSignOptions.entitlements;
            }
            if (customSignOptions.entitlementsInherit == null) {
                const p = `entitlements.${entitlementsSuffix}.inherit.plist`;
                if (resourceList.includes(p)) {
                    signOptions["entitlements-inherit"] = _path.join(_this4.info.buildResourcesDir, p);
                }
            } else {
                signOptions["entitlements-inherit"] = customSignOptions.entitlementsInherit;
            }
        })();
    }
    //noinspection JSMethodCanBeStatic
    doSign(opts) {
        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            return (0, (_electronOsxSign || _load_electronOsxSign()).signAsync)(opts);
        })();
    }
    //noinspection JSMethodCanBeStatic
    doFlat(appPath, outFile, identity, keychain) {
        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            // productbuild doesn't created directory for out file
            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(outFile));
            const args = (0, (_pkg || _load_pkg()).prepareProductBuildArgs)(identity, keychain);
            args.push("--component", appPath, "/Applications");
            args.push(outFile);
            return yield (0, (_builderUtil || _load_builderUtil()).exec)("productbuild", args);
        })();
    }
    getElectronSrcDir(dist) {
        return _path.resolve(this.projectDir, dist, this.electronDistMacOsAppName);
    }
    getElectronDestinationDir(appOutDir) {
        return _path.join(appOutDir, this.electronDistMacOsAppName);
    }
    beforeCopyExtraFiles(appOutDir, asarIntegrity) {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            yield (0, (_mac || _load_mac()).createMacApp)(_this5, appOutDir, asarIntegrity);
            const wantedLanguages = (0, (_out || _load_out()).asArray)(_this5.platformSpecificBuildOptions.electronLanguages);
            if (wantedLanguages.length === 0) {
                return;
            }
            // noinspection SpellCheckingInspection
            const langFileExt = ".lproj";
            const resourcesDir = _this5.getResourcesDir(appOutDir);
            yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map((0, (_fsExtraP || _load_fsExtraP()).readdir)(resourcesDir), function (file) {
                if (!file.endsWith(langFileExt)) {
                    return;
                }
                const language = file.substring(0, file.length - langFileExt.length);
                if (!wantedLanguages.includes(language)) {
                    return (0, (_fsExtraP || _load_fsExtraP()).remove)(_path.join(resourcesDir, file));
                }
                return;
            }, (_fs || _load_fs()).CONCURRENCY);
        })();
    }
}
exports.default = MacPackager;
function getCertificateType(isMas, isDevelopment) {
    if (isDevelopment) {
        return "Mac Developer";
    }
    return isMas ? "3rd Party Mac Developer Application" : "Developer ID Application";
}
//# sourceMappingURL=macPackager.js.map