"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LinuxPackager = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

exports.toAppImageOrSnapArch = toAppImageOrSnapArch;

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _sanitizeFilename;

function _load_sanitizeFilename() {
    return _sanitizeFilename = _interopRequireDefault(require("sanitize-filename"));
}

var _semver;

function _load_semver() {
    return _semver = _interopRequireWildcard(require("semver"));
}

var _core;

function _load_core() {
    return _core = require("./core");
}

var _platformPackager;

function _load_platformPackager() {
    return _platformPackager = require("./platformPackager");
}

var _RemoteBuilder;

function _load_RemoteBuilder() {
    return _RemoteBuilder = require("./remoteBuilder/RemoteBuilder");
}

var _LinuxTargetHelper;

function _load_LinuxTargetHelper() {
    return _LinuxTargetHelper = require("./targets/LinuxTargetHelper");
}

var _targetFactory;

function _load_targetFactory() {
    return _targetFactory = require("./targets/targetFactory");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class LinuxPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        super(info, (_core || _load_core()).Platform.LINUX);
        const executableName = this.platformSpecificBuildOptions.executableName;
        this.executableName = executableName == null ? this.appInfo.sanitizedName.toLowerCase() : (0, (_sanitizeFilename || _load_sanitizeFilename()).default)(executableName);
    }
    get isElectron2() {
        return (_semver || _load_semver()).gte(this.config.electronVersion || "1.8.3", "2.0.0-beta.1");
    }
    get defaultTarget() {
        return ["snap", "appimage"];
    }
    createTargets(targets, mapper) {
        let helper;
        const getHelper = () => {
            if (helper == null) {
                helper = new (_LinuxTargetHelper || _load_LinuxTargetHelper()).LinuxTargetHelper(this);
            }
            return helper;
        };
        let remoteBuilder = null;
        for (const name of targets) {
            if (name === (_core || _load_core()).DIR_TARGET) {
                continue;
            }
            const targetClass = (() => {
                switch (name) {
                    case "appimage":
                        return require("./targets/AppImageTarget").default;
                    case "snap":
                        return require("./targets/snap").default;
                    case "deb":
                    case "rpm":
                    case "sh":
                    case "freebsd":
                    case "pacman":
                    case "apk":
                    case "p5p":
                        return require("./targets/fpm").default;
                    default:
                        return null;
                }
            })();
            mapper(name, outDir => {
                if (targetClass === null) {
                    return (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this);
                }
                const target = new targetClass(name, this, getHelper(), outDir);
                if (process.platform === "win32" || process.env._REMOTE_BUILD) {
                    if (remoteBuilder == null) {
                        remoteBuilder = new (_RemoteBuilder || _load_RemoteBuilder()).RemoteBuilder(this);
                    }
                    // return remoteBuilder.buildTarget(this, arch, appOutDir, this.packager)
                    return new RemoteTarget(target, remoteBuilder);
                }
                return target;
            });
        }
    }
    postInitApp(packContext) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const executable = _path.join(packContext.appOutDir, _this.executableName);
            yield (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(packContext.appOutDir, _this.electronDistExecutableName), executable);
            if (!_this.isElectron2) {
                try {
                    yield (0, (_builderUtil || _load_builderUtil()).executeAppBuilder)(["clear-exec-stack", "--input", executable]);
                } catch (e) {
                    (_builderUtil || _load_builderUtil()).log.debug({ error: e }, "cannot clear exec stack");
                }
            }
        })();
    }
}
exports.LinuxPackager = LinuxPackager;
class RemoteTarget extends (_core || _load_core()).Target {
    constructor(target, remoteBuilder) {
        super(target.name, true /* all must be scheduled in time (so, on finishBuild RemoteBuilder will have all targets added - so, we must set isAsyncSupported to true (resolved promise is returned)) */);
        this.target = target;
        this.remoteBuilder = remoteBuilder;
        this.buildTaskManager = new (_builderUtil || _load_builderUtil()).AsyncTaskManager(this.remoteBuilder.packager.info.cancellationToken);
    }
    get options() {
        return this.target.options;
    }
    get outDir() {
        return this.target.outDir;
    }
    finishBuild() {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            yield _this2.buildTaskManager.awaitTasks();
            yield _this2.remoteBuilder.build();
        })();
    }
    build(appOutDir, arch) {
        const promise = this.doBuild(appOutDir, arch);
        this.buildTaskManager.addTask(promise);
        return promise;
    }
    doBuild(appOutDir, arch) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            (_builderUtil || _load_builderUtil()).log.info({ target: _this3.target.name, arch: (_builderUtil || _load_builderUtil()).Arch[arch] }, "scheduling remote build");
            yield _this3.target.checkOptions();
            _this3.remoteBuilder.scheduleBuild(_this3.target, arch, appOutDir);
        })();
    }
}
function toAppImageOrSnapArch(arch) {
    switch (arch) {
        case (_builderUtil || _load_builderUtil()).Arch.x64:
            return "x86_64";
        case (_builderUtil || _load_builderUtil()).Arch.ia32:
            return "i386";
        case (_builderUtil || _load_builderUtil()).Arch.armv7l:
            return "arm";
        case (_builderUtil || _load_builderUtil()).Arch.arm64:
            return "arm_aarch64";
        default:
            throw new Error(`Unsupported arch ${arch}`);
    }
}
//# sourceMappingURL=linuxPackager.js.map