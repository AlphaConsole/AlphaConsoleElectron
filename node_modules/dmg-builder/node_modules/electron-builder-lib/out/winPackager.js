"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WinPackager = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

let extractCommonNameUsingOpenssl = (() => {
    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (password, certPath) {
        const result = yield (0, (_builderUtil || _load_builderUtil()).exec)("openssl", ["pkcs12", "-nokeys", "-nodes", "-passin", `pass:${password}`, "-nomacver", "-clcerts", "-in", certPath], { timeout: 30 * 1000 }, debugOpenssl.enabled);
        const match = result.match(/^subject.*\/CN=([^\/\n]+)/m);
        if (match == null || match[1] == null) {
            throw new Error(`Cannot extract common name from p12: ${result}`);
        } else {
            return match[1];
        }
    });

    return function extractCommonNameUsingOpenssl(_x, _x2) {
        return _ref3.apply(this, arguments);
    };
})();
//# sourceMappingURL=winPackager.js.map


var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = require("builder-util-runtime");
}

var _crypto;

function _load_crypto() {
    return _crypto = require("crypto");
}

var _debug2 = _interopRequireDefault(require("debug"));

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _isCi;

function _load_isCi() {
    return _isCi = _interopRequireDefault(require("is-ci"));
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = require("lazy-val");
}

var _path = _interopRequireWildcard(require("path"));

var _codeSign;

function _load_codeSign() {
    return _codeSign = require("./codeSign");
}

var _core;

function _load_core() {
    return _core = require("./core");
}

var _platformPackager;

function _load_platformPackager() {
    return _platformPackager = require("./platformPackager");
}

var _NsisTarget;

function _load_NsisTarget() {
    return _NsisTarget = require("./targets/nsis/NsisTarget");
}

var _nsisUtil;

function _load_nsisUtil() {
    return _nsisUtil = require("./targets/nsis/nsisUtil");
}

var _WebInstallerTarget;

function _load_WebInstallerTarget() {
    return _WebInstallerTarget = require("./targets/nsis/WebInstallerTarget");
}

var _targetFactory;

function _load_targetFactory() {
    return _targetFactory = require("./targets/targetFactory");
}

var _cacheManager;

function _load_cacheManager() {
    return _cacheManager = require("./util/cacheManager");
}

var _flags;

function _load_flags() {
    return _flags = require("./util/flags");
}

var _timer;

function _load_timer() {
    return _timer = require("./util/timer");
}

var _vm;

function _load_vm() {
    return _vm = require("./vm/vm");
}

var _windowsCodeSign;

function _load_windowsCodeSign() {
    return _windowsCodeSign = require("./windowsCodeSign");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WinPackager extends (_platformPackager || _load_platformPackager()).PlatformPackager {
    constructor(info) {
        var _this;

        _this = super(info, (_core || _load_core()).Platform.WINDOWS);
        this.cscInfo = new (_lazyVal || _load_lazyVal()).Lazy(() => {
            const platformSpecificBuildOptions = this.platformSpecificBuildOptions;
            if (platformSpecificBuildOptions.certificateSubjectName != null || platformSpecificBuildOptions.certificateSha1 != null) {
                if (platformSpecificBuildOptions.sign != null) {
                    return Promise.resolve(null);
                }
                return this.vm.value.then(vm => (0, (_windowsCodeSign || _load_windowsCodeSign()).getCertificateFromStoreInfo)(platformSpecificBuildOptions, vm));
            }
            const certificateFile = platformSpecificBuildOptions.certificateFile;
            if (certificateFile != null) {
                const certificatePassword = this.getCscPassword();
                return Promise.resolve({
                    file: certificateFile,
                    password: certificatePassword == null ? null : certificatePassword.trim()
                });
            }
            const cscLink = this.getCscLink("WIN_CSC_LINK");
            if (cscLink == null) {
                return Promise.resolve(null);
            }
            return (0, (_codeSign || _load_codeSign()).downloadCertificate)(cscLink, this.info.tempDirManager, this.projectDir).then(path => {
                return {
                    file: path,
                    password: this.getCscPassword()
                };
            });
        });
        this._iconPath = new (_lazyVal || _load_lazyVal()).Lazy(() => this.getOrConvertIcon("ico"));
        this.vm = new (_lazyVal || _load_lazyVal()).Lazy(() => process.platform === "win32" ? Promise.resolve(new (_vm || _load_vm()).VmManager()) : (0, (_vm || _load_vm()).getWindowsVm)(this.debugLogger));
        this.computedPublisherSubjectOnWindowsOnly = new (_lazyVal || _load_lazyVal()).Lazy((0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const cscInfo = yield _this.cscInfo.value;
            if (cscInfo == null) {
                return null;
            }
            if ("subject" in cscInfo) {
                return cscInfo.subject;
            }
            const vm = yield _this.vm.value;
            const info = cscInfo;
            const certFile = vm.toVmFile(info.file);
            // https://github.com/electron-userland/electron-builder/issues/1735
            const args = info.password ? [`(Get-PfxData "${certFile}" -Password (ConvertTo-SecureString -String "${info.password}" -Force -AsPlainText)).EndEntityCertificates.Subject`] : [`(Get-PfxCertificate "${certFile}").Subject`];
            return yield vm.exec("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command"].concat(args), { timeout: 30 * 1000 }).then(function (it) {
                return it.trim();
            });
        }));
        this.computedPublisherName = new (_lazyVal || _load_lazyVal()).Lazy((0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let publisherName = _this.platformSpecificBuildOptions.publisherName;
            if (publisherName === null) {
                return null;
            }
            const cscInfo = yield _this.cscInfo.value;
            if (cscInfo == null) {
                return null;
            }
            if ("subject" in cscInfo) {
                return (0, (_builderUtil || _load_builderUtil()).asArray)((0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseDn)(cscInfo.subject).get("CN"));
            }
            const cscFile = cscInfo.file;
            if (publisherName == null && cscFile != null) {
                if (process.platform === "win32") {
                    try {
                        const subject = yield _this.computedPublisherSubjectOnWindowsOnly.value;
                        const commonName = subject == null ? null : (0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseDn)(subject).get("CN");
                        if (commonName) {
                            return (0, (_builderUtil || _load_builderUtil()).asArray)(commonName);
                        }
                    } catch (e) {
                        (_builderUtil || _load_builderUtil()).log.warn({ error: e.message }, "cannot get publisher name using powershell");
                    }
                }
                try {
                    publisherName = yield extractCommonNameUsingOpenssl(cscInfo.password || "", cscFile);
                } catch (e) {
                    throw new Error(`Cannot extract publisher name from code signing certificate, please file issue. As workaround, set win.publisherName: ${e.stack || e}`);
                }
            }
            return publisherName == null ? null : (0, (_builderUtil || _load_builderUtil()).asArray)(publisherName);
        }));
    }
    get isForceCodeSigningVerification() {
        return this.platformSpecificBuildOptions.verifyUpdateCodeSignature !== false;
    }
    get defaultTarget() {
        return ["nsis"];
    }
    doGetCscPassword() {
        return (0, (_platformPackager || _load_platformPackager()).chooseNotNull)((0, (_platformPackager || _load_platformPackager()).chooseNotNull)(this.platformSpecificBuildOptions.certificatePassword, process.env.WIN_CSC_KEY_PASSWORD), super.doGetCscPassword());
    }
    createTargets(targets, mapper) {
        let copyElevateHelper;
        const getCopyElevateHelper = () => {
            if (copyElevateHelper == null) {
                copyElevateHelper = new (_nsisUtil || _load_nsisUtil()).CopyElevateHelper();
            }
            return copyElevateHelper;
        };
        let helper;
        const getHelper = () => {
            if (helper == null) {
                helper = new (_nsisUtil || _load_nsisUtil()).AppPackageHelper(getCopyElevateHelper());
            }
            return helper;
        };
        for (const name of targets) {
            if (name === (_core || _load_core()).DIR_TARGET) {
                continue;
            }
            if (name === "nsis" || name === "portable") {
                mapper(name, outDir => new (_NsisTarget || _load_NsisTarget()).NsisTarget(this, outDir, name, getHelper()));
            } else if (name === "nsis-web") {
                // package file format differs from nsis target
                mapper(name, outDir => new (_WebInstallerTarget || _load_WebInstallerTarget()).WebInstallerTarget(this, _path.join(outDir, name), name, new (_nsisUtil || _load_nsisUtil()).AppPackageHelper(getCopyElevateHelper())));
            } else {
                const targetClass = (() => {
                    switch (name) {
                        case "squirrel":
                            try {
                                return require("electron-builder-squirrel-windows").default;
                            } catch (e) {
                                throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError(`Module electron-builder-squirrel-windows must be installed in addition to build Squirrel.Windows: ${e.stack || e}`);
                            }
                        case "appx":
                            return require("./targets/AppxTarget").default;
                        case "msi":
                            return require("./targets/MsiTarget").default;
                        default:
                            return null;
                    }
                })();
                mapper(name, outDir => targetClass === null ? (0, (_targetFactory || _load_targetFactory()).createCommonTarget)(name, outDir, this) : new targetClass(this, outDir, name));
            }
        }
    }
    getIconPath() {
        return this._iconPath.value;
    }
    sign(file, logMessagePrefix) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const signOptions = {
                path: file,
                name: _this2.appInfo.productName,
                site: yield _this2.appInfo.computePackageUrl(),
                options: _this2.platformSpecificBuildOptions
            };
            const cscInfo = yield _this2.cscInfo.value;
            if (cscInfo == null) {
                if (_this2.platformSpecificBuildOptions.sign != null) {
                    yield (0, (_windowsCodeSign || _load_windowsCodeSign()).sign)(signOptions, _this2);
                } else if (_this2.forceCodeSigning) {
                    throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError(`App is not signed and "forceCodeSigning" is set to true, please ensure that code signing configuration is correct, please see https://electron.build/code-signing`);
                }
                return;
            }
            if (logMessagePrefix == null) {
                logMessagePrefix = "signing";
            }
            if ("file" in cscInfo) {
                (_builderUtil || _load_builderUtil()).log.info({
                    file: (_builderUtil || _load_builderUtil()).log.filePath(file),
                    certificateFile: cscInfo.file
                }, logMessagePrefix);
            } else {
                const info = cscInfo;
                (_builderUtil || _load_builderUtil()).log.info({
                    file: (_builderUtil || _load_builderUtil()).log.filePath(file),
                    subject: info.subject,
                    thumbprint: info.thumbprint,
                    store: info.store,
                    user: info.isLocalMachineStore ? "local machine" : "current user"
                }, logMessagePrefix);
            }
            yield _this2.doSign(Object.assign({}, signOptions, { cscInfo, options: Object.assign({}, _this2.platformSpecificBuildOptions) }));
        })();
    }
    doSign(options) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            for (let i = 0; i < 3; i++) {
                try {
                    yield (0, (_windowsCodeSign || _load_windowsCodeSign()).sign)(options, _this3);
                    break;
                } catch (e) {
                    // https://github.com/electron-userland/electron-builder/issues/1414
                    const message = e.message;
                    if (message != null && message.includes("Couldn't resolve host name")) {
                        (_builderUtil || _load_builderUtil()).log.warn({ error: message, attempt: i + 1 }, `cannot sign`);
                        continue;
                    }
                    throw e;
                }
            }
        })();
    }
    signAndEditResources(file, arch, outDir, internalName, requestedExecutionLevel) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const appInfo = _this4.appInfo;
            const files = [];
            const args = [file, "--set-version-string", "FileDescription", appInfo.productName, "--set-version-string", "ProductName", appInfo.productName, "--set-version-string", "LegalCopyright", appInfo.copyright, "--set-file-version", appInfo.buildVersion, "--set-product-version", appInfo.versionInWeirdWindowsForm];
            if (internalName != null) {
                args.push("--set-version-string", "InternalName", internalName, "--set-version-string", "OriginalFilename", "");
            }
            if (requestedExecutionLevel != null && requestedExecutionLevel !== "asInvoker") {
                args.push("--set-requested-execution-level", requestedExecutionLevel);
            }
            (0, (_builderUtil || _load_builderUtil()).use)(appInfo.companyName, function (it) {
                return args.push("--set-version-string", "CompanyName", it);
            });
            (0, (_builderUtil || _load_builderUtil()).use)(_this4.platformSpecificBuildOptions.legalTrademarks, function (it) {
                return args.push("--set-version-string", "LegalTrademarks", it);
            });
            const iconPath = yield _this4.getIconPath();
            (0, (_builderUtil || _load_builderUtil()).use)(iconPath, function (it) {
                files.push(it);
                args.push("--set-icon", it);
            });
            const config = _this4.config;
            const cscInfoForCacheDigest = !(0, (_flags || _load_flags()).isBuildCacheEnabled)() || (_isCi || _load_isCi()).default || config.electronDist != null ? null : yield _this4.cscInfo.value;
            let buildCacheManager = null;
            // resources editing doesn't change executable for the same input and executed quickly - no need to complicate
            if (cscInfoForCacheDigest != null) {
                const cscFile = cscInfoForCacheDigest.file;
                if (cscFile != null) {
                    files.push(cscFile);
                }
                const timer = (0, (_timer || _load_timer()).time)("executable cache");
                const hash = (0, (_crypto || _load_crypto()).createHash)("sha512");
                hash.update(config.electronVersion || "no electronVersion");
                hash.update(config.muonVersion || "no muonVersion");
                hash.update(JSON.stringify(_this4.platformSpecificBuildOptions));
                hash.update(JSON.stringify(args));
                hash.update(_this4.platformSpecificBuildOptions.certificateSha1 || "no certificateSha1");
                hash.update(_this4.platformSpecificBuildOptions.certificateSubjectName || "no subjectName");
                buildCacheManager = new (_cacheManager || _load_cacheManager()).BuildCacheManager(outDir, file, arch);
                if (yield buildCacheManager.copyIfValid((yield (0, (_cacheManager || _load_cacheManager()).digest)(hash, files)))) {
                    timer.end();
                    return;
                }
                timer.end();
            }
            const timer = (0, (_timer || _load_timer()).time)("wine&sign");
            yield (0, (_builderUtil || _load_builderUtil()).execWine)(_path.join((yield (0, (_windowsCodeSign || _load_windowsCodeSign()).getSignVendorPath)()), "rcedit.exe"), args);
            yield _this4.sign(file);
            timer.end();
            if (buildCacheManager != null) {
                yield buildCacheManager.save();
            }
        })();
    }
    postInitApp(packContext) {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const executable = _path.join(packContext.appOutDir, `${_this5.appInfo.productFilename}.exe`);
            yield (0, (_fsExtraP || _load_fsExtraP()).rename)(_path.join(packContext.appOutDir, `${_this5.electronDistExecutableName}.exe`), executable);
        })();
    }
    signApp(packContext) {
        var _this6 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const exeFileName = `${_this6.appInfo.productFilename}.exe`;
            if (_this6.platformSpecificBuildOptions.signAndEditExecutable !== false) {
                yield _this6.signAndEditResources(_path.join(packContext.appOutDir, exeFileName), packContext.arch, packContext.outDir, _path.basename(exeFileName, ".exe"), _this6.platformSpecificBuildOptions.requestedExecutionLevel);
            }
        })();
    }
}
exports.WinPackager = WinPackager;
const debugOpenssl = (0, _debug2.default)("electron-builder:openssl");