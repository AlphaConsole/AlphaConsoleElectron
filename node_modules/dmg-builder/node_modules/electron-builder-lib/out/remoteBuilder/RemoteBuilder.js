"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RemoteBuilder = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let findBuildAgent = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
        const result = process.env.ELECTRON_BUILD_SERVICE_ENDPOINT;
        if (result != null) {
            (_builderUtil || _load_builderUtil()).log.debug({ endpoint: result }, `endpoint is set explicitly`);
            return result.startsWith("http") ? result : `https://${result}`;
        }
        const rawUrl = process.env.ELECTRON_BUILD_SERVICE_ROUTER_HOST || "service.electron.build";
        // add random query param to prevent caching
        const routerUrl = rawUrl.startsWith("http") ? rawUrl : `https://${rawUrl}`;
        (_builderUtil || _load_builderUtil()).log.debug({ routerUrl }, "");
        const client = (0, (_http || _load_http()).connect)(routerUrl, (0, (_RemoteBuildManager || _load_RemoteBuildManager()).getConnectOptions)());
        return yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
            client.on("socketError", reject);
            client.on("error", reject);
            client.setTimeout(10 * 1000, function () {
                reject(new Error("Timeout"));
            });
            const stream = client.request({
                [(_http || _load_http()).constants.HTTP2_HEADER_PATH]: `/find-build-agent?c=${Date.now().toString(32)}`,
                [(_http || _load_http()).constants.HTTP2_HEADER_METHOD]: (_http || _load_http()).constants.HTTP2_METHOD_GET
            });
            stream.on("error", reject);
            stream.on("response", function (headers) {
                if (!(0, (_RemoteBuildManager || _load_RemoteBuildManager()).checkStatus)(headers[(_http || _load_http()).constants.HTTP2_HEADER_STATUS], reject)) {
                    return;
                }
                stream.setEncoding("utf8");
                let data = "";
                stream.on("end", function () {
                    try {
                        if ((_builderUtil || _load_builderUtil()).log.isDebugEnabled) {
                            (_builderUtil || _load_builderUtil()).log.debug({ data }, "remote build response");
                        }
                        resolve(JSON.parse(data).endpoint);
                    } catch (e) {
                        throw new Error(`Cannot parse response: ${data}`);
                    }
                });
                stream.on("data", function (chunk) {
                    data += chunk;
                });
            });
        }).finally(function () {
            client.destroy();
        });
    });

    return function findBuildAgent() {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=RemoteBuilder.js.map


var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _http;

function _load_http() {
    return _http = require("http2");
}

var _path = _interopRequireWildcard(require("path"));

var _util;

function _load_util() {
    return _util = require("util");
}

var _ProjectInfoManager;

function _load_ProjectInfoManager() {
    return _ProjectInfoManager = require("./ProjectInfoManager");
}

var _RemoteBuildManager;

function _load_RemoteBuildManager() {
    return _RemoteBuildManager = require("./RemoteBuildManager");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const errorCodes = new Set(["ECONNREFUSED", "ECONNRESET"]);
class RemoteBuilder {
    constructor(packager) {
        this.packager = packager;
        this.toBuild = new Map();
        this.buildStarted = false;
    }
    scheduleBuild(target, arch, unpackedDirectory) {
        if (!(0, (_builderUtil || _load_builderUtil()).isEnvTrue)(process.env._REMOTE_BUILD) && this.packager.config.remoteBuild === false) {
            throw new Error("Target is not supported on your OS and using of Electron Build Service is disabled (\"remoteBuild\" option)");
        }
        let list = this.toBuild.get(arch);
        if (list == null) {
            list = [];
            this.toBuild.set(arch, list);
        }
        list.push({
            name: target.name,
            arch: (_builderUtil || _load_builderUtil()).Arch[arch],
            unpackedDirectory,
            outDir: target.outDir
        });
    }
    build() {
        if (this.buildStarted) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
        }
        this.buildStarted = true;
        return (_bluebirdLst2 || _load_bluebirdLst2()).default.mapSeries(Array.from(this.toBuild.keys()), arch => {
            return this._build(this.toBuild.get(arch), this.packager);
        });
    }
    // noinspection JSMethodCanBeStatic
    _build(targets, packager) {
        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if ((_builderUtil || _load_builderUtil()).log.isDebugEnabled) {
                (_builderUtil || _load_builderUtil()).log.debug({ remoteTargets: JSON.stringify(targets, null, 2) }, "remote building");
            }
            const projectInfoManager = new (_ProjectInfoManager || _load_ProjectInfoManager()).ProjectInfoManager(packager.info);
            let result = null;
            for (let attempt = 0; true; attempt++) {
                const endpoint = yield findBuildAgent();
                // for now assume that all targets has the same outDir (correct for Linux)
                const buildManager = new (_RemoteBuildManager || _load_RemoteBuildManager()).RemoteBuildManager(endpoint, projectInfoManager, targets[0].unpackedDirectory, targets[0].outDir, packager);
                const setTimeoutPromise = (0, (_util || _load_util()).promisify)(setTimeout);
                try {
                    result = yield buildManager.build({
                        "x-targets": JSON.stringify(targets.map(function (it) {
                            return {
                                name: it.name,
                                arch: it.arch,
                                unpackedDirName: _path.basename(it.unpackedDirectory)
                            };
                        })),
                        "x-platform": packager.platform.buildConfigurationKey
                    });
                    break;
                } catch (e) {
                    const errorCode = e.code;
                    if (!errorCodes.has(errorCode) || attempt > 3) {
                        if (errorCode === "ECONNREFUSED") {
                            const error = new Error(`Cannot connect to electron build service ${endpoint}: ${e.message}`);
                            e.code = errorCode;
                            throw error;
                        } else {
                            throw e;
                        }
                    }
                    const waitTime = 4000 * (attempt + 1);
                    console.warn(`Attempt ${attempt + 1}: ${e.message}\nWaiting ${waitTime / 1000}s...`);
                    yield setTimeoutPromise(waitTime, "wait");
                }
            }
            if (result != null && result.error != null) {
                throw new Error(`Remote builder error (if you think that it is not your application misconfiguration issue, please file issue to https://github.com/electron-userland/electron-builder/issues):\n\n${result.error}`);
            }
        })();
    }
}
exports.RemoteBuilder = RemoteBuilder;