"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProjectInfoManager = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = require("lazy-val");
}

var _path = _interopRequireWildcard(require("path"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class ProjectInfoManager {
    constructor(packager) {
        this.packager = packager;
        this.infoFile = new (_lazyVal || _load_lazyVal()).Lazy(() => this.saveConfigurationAndMetadata());
    }
    saveConfigurationAndMetadata() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            const tempDir = yield packager.tempDirManager.createTempDir({ prefix: "remote-build-metadata" });
            // we cannot use getTempFile because file name must be constant
            const info = {
                metadata: packager.metadata,
                configuration: packager.config,
                repositoryInfo: yield packager.repositoryInfo,
                buildResourceDirName: _path.basename(packager.buildResourcesDir)
            };
            if (packager.metadata !== packager.devMetadata && packager.devMetadata != null) {
                info.devMetadata = packager.devMetadata;
            }
            const file = _path.join(tempDir, "info.json");
            yield (0, (_fsExtraP || _load_fsExtraP()).outputJson)(file, info);
            return file;
        })();
    }
}
exports.ProjectInfoManager = ProjectInfoManager; //# sourceMappingURL=ProjectInfoManager.js.map