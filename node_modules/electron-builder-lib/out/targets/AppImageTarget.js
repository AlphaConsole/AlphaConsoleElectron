"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = require("builder-util-runtime");
}

var _fs;

function _load_fs() {
    return _fs = require("builder-util/out/fs");
}

var _ejs;

function _load_ejs() {
    return _ejs = _interopRequireWildcard(require("ejs"));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = require("lazy-val");
}

var _path = _interopRequireWildcard(require("path"));

var _core;

function _load_core() {
    return _core = require("../core");
}

var _PublishManager;

function _load_PublishManager() {
    return _PublishManager = require("../publish/PublishManager");
}

var _pathManager;

function _load_pathManager() {
    return _pathManager = require("../util/pathManager");
}

var _targetUtil;

function _load_targetUtil() {
    return _targetUtil = require("./targetUtil");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const appRunTemplate = new (_lazyVal || _load_lazyVal()).Lazy((0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
    return (_ejs || _load_ejs()).compile((yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join((0, (_pathManager || _load_pathManager()).getTemplatePath)("linux"), "AppRun.sh"), "utf-8")));
}));
// https://unix.stackexchange.com/questions/375191/append-to-sub-directory-inside-squashfs-file
class AppImageTarget extends (_core || _load_core()).Target {
    constructor(ignored, packager, helper, outDir) {
        super("appImage");
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
        // we add X-AppImage-BuildId to ensure that new desktop file will be installed
        this.desktopEntry = new (_lazyVal || _load_lazyVal()).Lazy(() => helper.computeDesktopEntry(this.options, "AppRun", {
            "X-AppImage-Version": `${packager.appInfo.buildVersion}`,
            "X-AppImage-BuildId": (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.v1()
        }));
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this.packager;
            // https://github.com/electron-userland/electron-builder/issues/775
            // https://github.com/electron-userland/electron-builder/issues/1726
            // tslint:disable-next-line:no-invalid-template-strings
            const artifactName = packager.expandArtifactNamePattern(_this.options, "AppImage", arch, "${name}-${version}-${arch}.${ext}", false);
            const artifactPath = _path.join(_this.outDir, artifactName);
            _this.logBuilding("AppImage", artifactPath, arch);
            const stageDir = yield (0, (_targetUtil || _load_targetUtil()).createStageDir)(_this, packager, arch);
            const resourceName = `appimagekit-${_this.packager.executableName}`;
            const installIcons = yield _this.copyIcons(stageDir.dir, resourceName);
            const finalDesktopFilename = `${_this.packager.executableName}.desktop`;
            yield Promise.all([(0, (_fs || _load_fs()).unlinkIfExists)(artifactPath), (0, (_fsExtraP || _load_fsExtraP()).writeFile)(stageDir.getTempFile("/AppRun"), (yield appRunTemplate.value)({
                systemIntegration: _this.options.systemIntegration || "ask",
                desktopFileName: finalDesktopFilename,
                executableName: _this.packager.executableName,
                resourceName,
                installIcons
            }), {
                mode: "0755"
            }), (0, (_fsExtraP || _load_fsExtraP()).writeFile)(stageDir.getTempFile(finalDesktopFilename), (yield _this.desktopEntry.value))]);
            // must be after this.helper.icons call
            if (_this.helper.maxIconPath == null) {
                throw new Error("Icon is not provided");
            }
            if (_this.packager.packagerOptions.effectiveOptionComputed != null && (yield _this.packager.packagerOptions.effectiveOptionComputed({ desktop: yield _this.desktopEntry.value }))) {
                return;
            }
            const publishConfig = yield (0, (_PublishManager || _load_PublishManager()).getAppUpdatePublishConfiguration)(packager, arch);
            if (publishConfig != null) {
                yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(_path.join(packager.getResourcesDir(stageDir.getTempFile("app")), "app-update.yml"), (0, (_builderUtil || _load_builderUtil()).serializeToYaml)(publishConfig));
            }
            const args = ["appimage", "--stage", stageDir.dir, "--arch", (_builderUtil || _load_builderUtil()).Arch[arch], "--output", artifactPath, "--app", appOutDir];
            if (packager.compression === "maximum") {
                args.push("--compression", "xz");
            }
            packager.info.dispatchArtifactCreated({
                file: artifactPath,
                safeArtifactName: packager.computeSafeArtifactName(artifactName, "AppImage", arch, false),
                target: _this,
                arch,
                packager,
                isWriteUpdateInfo: true,
                updateInfo: JSON.parse((yield (0, (_builderUtil || _load_builderUtil()).executeAppBuilder)(args)))
            });
        })();
    }
    copyIcons(stageDir, resourceName) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const iconDirRelativePath = "usr/share/icons/hicolor";
            const iconDir = _path.join(stageDir, iconDirRelativePath);
            yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(iconDir);
            // https://github.com/AppImage/AppImageKit/issues/438#issuecomment-319094239
            // expects icons in the /usr/share/icons/hicolor
            const iconNames = yield (_bluebirdLst2 || _load_bluebirdLst2()).default.map(_this2.helper.icons, (() => {
                var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (icon) {
                    const filename = `${_this2.packager.executableName}.png`;
                    const iconSizeDir = `${icon.size}x${icon.size}/apps`;
                    const dir = _path.join(iconDir, iconSizeDir);
                    yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(dir);
                    const finalIconFile = _path.join(dir, filename);
                    yield (0, (_fs || _load_fs()).copyOrLinkFile)(icon.file, finalIconFile, null, true);
                    if (icon.file === _this2.helper.maxIconPath) {
                        yield (0, (_fsExtraP || _load_fsExtraP()).symlink)(_path.relative(stageDir, finalIconFile), _path.join(stageDir, filename));
                    }
                    return { filename, iconSizeDir, size: icon.size };
                });

                return function (_x) {
                    return _ref2.apply(this, arguments);
                };
            })());
            let installIcons = "";
            for (const icon of iconNames) {
                installIcons += `xdg-icon-resource install --noupdate --context apps --size ${icon.size} "$APPDIR/${iconDirRelativePath}/${icon.iconSizeDir}/${icon.filename}" "${resourceName}"\n`;
            }
            return installIcons;
        })();
    }
}
exports.default = AppImageTarget; //# sourceMappingURL=AppImageTarget.js.map