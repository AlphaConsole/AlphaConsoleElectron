"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let writeConfigFile = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tmpDir, templatePath, options) {
        //noinspection JSUnusedLocalSymbols
        function replacer(match, p1) {
            if (p1 in options) {
                return options[p1];
            } else {
                throw new Error(`Macro ${p1} is not defined`);
            }
        }
        const config = (yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(templatePath, "utf8")).replace(/\${([a-zA-Z]+)}/g, replacer).replace(/<%=([a-zA-Z]+)%>/g, function (match, p1) {
            (_builderUtil || _load_builderUtil()).log.warn("<%= varName %> is deprecated, please use ${varName} instead");
            return replacer(match, p1.trim());
        });
        const outputPath = yield tmpDir.getTempFile({ suffix: _path.basename(templatePath, ".tpl") });
        yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(outputPath, config);
        return outputPath;
    });

    return function writeConfigFile(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=fpm.js.map


var _zipBin;

function _load_zipBin() {
    return _zipBin = require("7zip-bin");
}

var _appBuilderBin;

function _load_appBuilderBin() {
    return _appBuilderBin = require("app-builder-bin");
}

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _bundledTool;

function _load_bundledTool() {
    return _bundledTool = require("builder-util/out/bundledTool");
}

var _fs;

function _load_fs() {
    return _fs = require("builder-util/out/fs");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _core;

function _load_core() {
    return _core = require("../core");
}

var _errorMessages;

function _load_errorMessages() {
    return _errorMessages = _interopRequireWildcard(require("../errorMessages"));
}

var _pathManager;

function _load_pathManager() {
    return _pathManager = require("../util/pathManager");
}

var _LinuxTargetHelper;

function _load_LinuxTargetHelper() {
    return _LinuxTargetHelper = require("./LinuxTargetHelper");
}

var _tools;

function _load_tools() {
    return _tools = require("./tools");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class FpmTarget extends (_core || _load_core()).Target {
    constructor(name, packager, helper, outDir) {
        super(name, false);
        this.packager = packager;
        this.helper = helper;
        this.outDir = outDir;
        this.options = Object.assign({}, this.packager.platformSpecificBuildOptions, this.packager.config[this.name]);
        this.scriptFiles = this.createScripts();
    }
    createScripts() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const defaultTemplatesDir = (0, (_pathManager || _load_pathManager()).getTemplatePath)("linux");
            const packager = _this.packager;
            const templateOptions = Object.assign({
                // old API compatibility
                executable: packager.executableName, productFilename: packager.appInfo.productFilename }, packager.platformSpecificBuildOptions);
            function getResource(value, defaultFile) {
                if (value == null) {
                    return _path.join(defaultTemplatesDir, defaultFile);
                }
                return _path.resolve(packager.projectDir, value);
            }
            return yield (_bluebirdLst2 || _load_bluebirdLst2()).default.all([writeConfigFile(packager.info.tempDirManager, getResource(_this.options.afterInstall, "after-install.tpl"), templateOptions), writeConfigFile(packager.info.tempDirManager, getResource(_this.options.afterRemove, "after-remove.tpl"), templateOptions)]);
        })();
    }
    checkOptions() {
        return this.computeFpmMetaInfoOptions();
    }
    computeFpmMetaInfoOptions() {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packager = _this2.packager;
            const projectUrl = yield packager.appInfo.computePackageUrl();
            const errors = [];
            if (projectUrl == null) {
                errors.push("Please specify project homepage, see https://electron.build/configuration/configuration#Metadata-homepage");
            }
            const options = _this2.options;
            let author = options.maintainer;
            if (author == null) {
                const a = packager.info.metadata.author;
                if (a == null || a.email == null) {
                    errors.push((_errorMessages || _load_errorMessages()).authorEmailIsMissed);
                } else {
                    author = `${a.name} <${a.email}>`;
                }
            }
            if (errors.length > 0) {
                throw new Error(errors.join("\n\n"));
            }
            return {
                maintainer: author,
                url: projectUrl,
                vendor: options.vendor || author
            };
        })();
    }
    build(appOutDir, arch) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const fpmMetaInfoOptions = yield _this3.computeFpmMetaInfoOptions();
            const target = _this3.name;
            // tslint:disable:no-invalid-template-strings
            let nameFormat = "${name}-${version}-${arch}.${ext}";
            let isUseArchIfX64 = false;
            if (target === "deb") {
                nameFormat = "${name}_${version}_${arch}.${ext}";
                isUseArchIfX64 = true;
            } else if (target === "rpm") {
                nameFormat = "${name}-${version}.${arch}.${ext}";
                isUseArchIfX64 = true;
            }
            const artifactPath = _path.join(_this3.outDir, _this3.packager.expandArtifactNamePattern(_this3.options, target, arch, nameFormat, !isUseArchIfX64));
            _this3.logBuilding(target, artifactPath, arch);
            yield (0, (_fs || _load_fs()).unlinkIfExists)(artifactPath);
            if (_this3.packager.packagerOptions.prepackaged != null) {
                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_this3.outDir);
            }
            const scripts = yield _this3.scriptFiles;
            const packager = _this3.packager;
            const appInfo = packager.appInfo;
            const options = _this3.options;
            const synopsis = options.synopsis;
            const args = ["-s", "dir", "-t", target, "--architecture", target === "pacman" && arch === (_builderUtil || _load_builderUtil()).Arch.ia32 ? "i686" : (0, (_builderUtil || _load_builderUtil()).toLinuxArchString)(arch), "--name", appInfo.name, "--force", "--after-install", scripts[0], "--after-remove", scripts[1], "--description", (0, (_builderUtil || _load_builderUtil()).smarten)(target === "rpm" ? _this3.helper.getDescription(options) : `${synopsis || ""}\n ${_this3.helper.getDescription(options)}`), "--version", appInfo.version, "--package", artifactPath];
            for (const key of Object.keys(fpmMetaInfoOptions)) {
                const value = fpmMetaInfoOptions[key];
                if (value != null) {
                    args.push(`--${key}`, value);
                }
            }
            if ((_builderUtil || _load_builderUtil()).debug.enabled) {
                args.push("--log", "debug", "--debug");
            }
            const packageCategory = options.packageCategory;
            if (packageCategory != null && packageCategory !== null) {
                args.push("--category", packageCategory);
            }
            const compression = options.compression;
            if (target === "deb") {
                args.push("--deb-compression", compression || "xz");
                (0, (_builderUtil || _load_builderUtil()).use)(options.priority, function (it) {
                    return args.push("--deb-priority", it);
                });
            } else if (target === "rpm") {
                args.push("--rpm-compression", (compression === "xz" ? "xzmt" : compression) || "xzmt");
                args.push("--rpm-os", "linux");
                if (synopsis != null) {
                    args.push("--rpm-summary", (0, (_builderUtil || _load_builderUtil()).smarten)(synopsis));
                }
            }
            // noinspection JSDeprecatedSymbols
            let depends = options.depends || _this3.packager.platformSpecificBuildOptions.depends;
            if (depends == null) {
                if (target === "deb") {
                    depends = ["gconf2", "gconf-service", "libnotify4", "libappindicator1", "libxtst6", "libnss3", "libxss1"];
                } else if (target === "pacman") {
                    // noinspection SpellCheckingInspection
                    depends = ["c-ares", "ffmpeg", "gtk3", "http-parser", "libevent", "libvpx", "libxslt", "libxss", "minizip", "nss", "re2", "snappy", "libnotify", "libappindicator-gtk2", "libappindicator-gtk3", "libappindicator-sharp"];
                } else if (target === "rpm") {
                    // noinspection SpellCheckingInspection
                    depends = ["libnotify", "libappindicator", "libXScrnSaver"];
                } else {
                    depends = [];
                }
            } else if (!Array.isArray(depends)) {
                // noinspection SuspiciousTypeOfGuard
                if (typeof depends === "string") {
                    depends = [depends];
                } else {
                    throw new Error(`depends must be Array or String, but specified as: ${depends}`);
                }
            }
            for (const dep of depends) {
                args.push("--depends", dep);
            }
            (0, (_builderUtil || _load_builderUtil()).use)(packager.info.metadata.license, function (it) {
                return args.push("--license", it);
            });
            (0, (_builderUtil || _load_builderUtil()).use)(appInfo.buildNumber, function (it) {
                return args.push("--iteration", it);
            });
            (0, (_builderUtil || _load_builderUtil()).use)(options.fpm, function (it) {
                return args.push(...it);
            });
            args.push(`${appOutDir}/=${(_LinuxTargetHelper || _load_LinuxTargetHelper()).installPrefix}/${appInfo.productFilename}`);
            for (const icon of yield _this3.helper.icons) {
                args.push(`${icon.file}=/usr/share/icons/hicolor/${icon.size}x${icon.size}/apps/${packager.executableName}.png`);
            }
            const desktopFilePath = yield _this3.helper.writeDesktopEntry(_this3.options);
            args.push(`${desktopFilePath}=/usr/share/applications/${_this3.packager.executableName}.desktop`);
            if (_this3.packager.packagerOptions.effectiveOptionComputed != null && (yield _this3.packager.packagerOptions.effectiveOptionComputed([args, desktopFilePath]))) {
                return;
            }
            const env = Object.assign({}, process.env, { FPM_COMPRESS_PROGRAM: (_appBuilderBin || _load_appBuilderBin()).appBuilderPath, SZA_PATH: (_zipBin || _load_zipBin()).path7za, SZA_COMPRESSION_LEVEL: packager.compression === "store" ? "0" : "9", SZA_ARCHIVE_TYPE: "xz" });
            // rpmbuild wants directory rpm with some default config files. Even if we can use dylibbundler, path to such config files are not changed (we need to replace in the binary)
            // so, for now, brew install rpm is still required.
            if (target !== "rpm" && (yield (0, (_builderUtil || _load_builderUtil()).isMacOsSierra)())) {
                const linuxToolsPath = yield (0, (_tools || _load_tools()).getLinuxToolsPath)();
                Object.assign(env, {
                    PATH: (0, (_bundledTool || _load_bundledTool()).computeEnv)(process.env.PATH, [_path.join(linuxToolsPath, "bin")]),
                    DYLD_LIBRARY_PATH: (0, (_bundledTool || _load_bundledTool()).computeEnv)(process.env.DYLD_LIBRARY_PATH, [_path.join(linuxToolsPath, "lib")])
                });
            }
            yield (0, (_builderUtil || _load_builderUtil()).exec)((yield (_tools || _load_tools()).fpmPath.value), args, { env });
            _this3.packager.dispatchArtifactCreated(artifactPath, _this3, arch);
        })();
    }
}
exports.default = FpmTarget;