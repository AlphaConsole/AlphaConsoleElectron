{"version":3,"file":"xml.js","sourceRoot":"","sources":["../src/xml.ts"],"names":[],"mappings":"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","sourcesContent":["import * as sax from \"sax\"\nimport { newError } from \"./index\"\n\nexport class XElement {\n  value = \"\"\n  attributes: { [key: string]: string } | null = null\n  isCData = false\n  elements: Array<XElement> | null = null\n\n  constructor(readonly name: string) {\n    if (!name) {\n      throw newError(\"Element name cannot be empty\", \"ERR_XML_ELEMENT_NAME_EMPTY\")\n    }\n    if (!isValidName(name)) {\n      throw newError(`Invalid element name: ${name}`, \"ERR_XML_ELEMENT_INVALID_NAME\")\n    }\n  }\n\n  attribute(name: string): string {\n    const result = this.attributes === null ? null : this.attributes[name]\n    if (result == null) {\n      throw newError(`No attribute \"${name}\"`, \"ERR_XML_MISSED_ATTRIBUTE\")\n    }\n    return result\n  }\n\n  removeAttribute(name: string): void {\n    if (this.attributes !== null) {\n      delete this.attributes[name]\n    }\n  }\n\n  element(name: string, ignoreCase = false, errorIfMissed: string | null = null): XElement {\n    const result = this.elementOrNull(name, ignoreCase)\n    if (result === null) {\n      throw newError(errorIfMissed || `No element \"${name}\"`, \"ERR_XML_MISSED_ELEMENT\")\n    }\n    return result\n  }\n\n  elementOrNull(name: string, ignoreCase = false): XElement | null {\n    if (this.elements === null) {\n      return null\n    }\n\n    for (const element of this.elements) {\n      if (isNameEquals(element, name, ignoreCase)) {\n        return element\n      }\n    }\n\n    return null\n  }\n\n  getElements(name: string, ignoreCase = false) {\n    if (this.elements === null) {\n      return []\n    }\n    return this.elements.filter(it => isNameEquals(it, name, ignoreCase))\n  }\n\n  elementValueOrEmpty(name: string, ignoreCase = false): string {\n    const element = this.elementOrNull(name, ignoreCase)\n    return element === null ? \"\" : element.value\n  }\n}\n\nconst NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i)\n\nfunction isValidName(name: string) {\n  return (NAME_REG_EXP.test(name))\n}\n\nfunction isNameEquals(element: XElement, name: string, ignoreCase: boolean) {\n  const elementName = element.name\n  return elementName === name || (ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase())\n}\n\nexport function parseXml(data: string): XElement {\n  let rootElement: XElement | null = null\n  const parser = sax.parser(true, {})\n  const elements: Array<XElement> = []\n\n  parser.onopentag = saxElement => {\n    const element = new XElement(saxElement.name)\n    element.attributes = saxElement.attributes as { [key: string]: string }\n\n    if (rootElement === null) {\n      rootElement = element\n    }\n    else {\n      const parent = elements[elements.length - 1]\n      if (parent.elements == null) {\n        parent.elements = []\n      }\n      parent.elements.push(element)\n    }\n    elements.push(element)\n  }\n\n  parser.onclosetag = () => {\n    elements.pop()\n  }\n\n  parser.ontext = text => {\n    if (elements.length > 0) {\n      elements[elements.length - 1].value = text\n    }\n  }\n\n  parser.oncdata = cdata => {\n    const element = elements[elements.length - 1]\n    element.value = cdata\n    element.isCData = true\n  }\n\n  parser.onerror = err => {\n    throw err\n  }\n\n  parser.write(data)\n  return rootElement!!\n}"]}
